<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
    <a-scene>
        <!-- Sky/Background -->
        <a-sky color="#000022"></a-sky>

		<!-- Player Ship - note the component name change -->
		<a-entity id="player" quest-player-controls player-health player-shooting
          geometry="primitive: box; width: 0.5; height: 0.3; depth: 0.2"
          material="color: #00ff00"
          position="0 -2 -3">
		</a-entity>
        
        <!-- Enemy Spawner -->
        <a-entity enemy-spawner></a-entity>
		
		<!-- Fixed Quest 3 Controllers -->
<a-entity id="leftController" 
          oculus-touch-controls="hand: left; model: true"
          tracked-controls="controller: 0; idPrefix: oculus-touch-controls">
</a-entity>
<a-entity id="rightController" 
          oculus-touch-controls="hand: right; model: true"
          tracked-controls="controller: 1; idPrefix: oculus-touch-controls">
</a-entity>
        
        <a-camera position="0 0 3"></a-camera>
		
    </a-scene>

    <script>
        // Enemy Collision System (Tetris-style stacking)
        AFRAME.registerComponent('simple-stack-collision', {
            init: function () {
                this.isMoving = true;
                this.groundLevel = -3.5;
            },
            
            tick: function () {
                if (!this.isMoving) return;
                
                let myPosition = this.el.getAttribute('position');
                
                if (myPosition.y <= this.groundLevel) {
                    this.stopAtPosition(myPosition.x, this.groundLevel);
                    return;
                }
                
                this.checkEnemyCollisions(myPosition);
            },
            
            checkEnemyCollisions: function(myPosition) {
                let enemies = document.querySelectorAll('.enemy');
                
                for (let enemy of enemies) {
                    if (enemy === this.el) continue;
                    if (enemy.components['simple-stack-collision'] && enemy.components['simple-stack-collision'].isMoving) continue;
                    
                    let otherPosition = enemy.getAttribute('position');
                    
                    let horizontalDist = Math.abs(myPosition.x - otherPosition.x);
                    if (horizontalDist < 0.3) {
                        let verticalDist = myPosition.y - otherPosition.y;
                        if (verticalDist > 0 && verticalDist < 0.6) {
                            this.stopAtPosition(otherPosition.x, otherPosition.y + 0.4);
                            return;
                        }
                    }
                }
            },
            
            stopAtPosition: function(x, y) {
                this.isMoving = false;
                this.el.removeAttribute('animation');
                this.el.setAttribute('position', {x: x, y: y, z: -3});
                this.el.setAttribute('material', 'color: blue');
                console.log(`Enemy stopped at position: ${x}, ${y}`);
            }
        });

        // Enemy Spawner
        AFRAME.registerComponent('enemy-spawner', {
            init: function () {
                this.spawnTimer = 0;
                this.spawnInterval = 2000;
                this.enemyCount = 0;
            },
            
            tick: function (time, deltaTime) {
                this.spawnTimer += deltaTime;
                
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnEnemy();
                    this.spawnTimer = 0;
                }
            },
            
            spawnEnemy: function () {
                let enemy = document.createElement('a-entity');
                enemy.setAttribute('geometry', 'primitive: box; width: 0.4; height: 0.4; depth: 0.2');
                enemy.setAttribute('material', 'color: red');
                enemy.setAttribute('simple-stack-collision', '');
                
                let randomX = (Math.random() - 0.5) * 6;
                enemy.setAttribute('position', `${randomX} 3 -3`);
                enemy.setAttribute('animation', 'property: position; to: ' + randomX + ' -4 -3; dur: 4000');
                
                enemy.setAttribute('class', 'enemy');
                enemy.setAttribute('id', 'enemy-' + this.enemyCount);
                this.enemyCount++;
                
                document.querySelector('a-scene').appendChild(enemy);
                console.log('Enemy spawned at position:', randomX);
            }
        });
		AFRAME.registerComponent('player-health', {
    init: function () {
        this.health = 3;
        this.maxHealth = 3;
        this.invulnerable = false;
        this.invulnerabilityTime = 1000; // 1 second of invulnerability after hit
        this.createHealthDisplay();
    },
    
    tick: function () {
        this.checkEnemyCollisions();
    },
    
    checkEnemyCollisions: function () {
        if (this.invulnerable) return;
        
        let playerPosition = this.el.getAttribute('position');
        let enemies = document.querySelectorAll('.enemy');
        
        enemies.forEach((enemy) => {
            let enemyPosition = enemy.getAttribute('position');
            let distance = this.getDistance(playerPosition, enemyPosition);
            
            // If collision detected
            if (distance < 0.6) {
                this.takeDamage();
                // Remove the enemy that hit the player
                enemy.parentNode.removeChild(enemy);
            }
        });
    },
    
    getDistance: function (pos1, pos2) {
        let dx = pos1.x - pos2.x;
        let dy = pos1.y - pos2.y;
        let dz = pos1.z - pos2.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
    },
    
    takeDamage: function () {
        this.health--;
        this.updateHealthDisplay();
        
        // Flash red when hit
        this.el.setAttribute('material', 'color: red');
        setTimeout(() => {
            this.el.setAttribute('material', 'color: #00ff00');
        }, 200);
        
        // Temporary invulnerability
        this.invulnerable = true;
        setTimeout(() => {
            this.invulnerable = false;
        }, this.invulnerabilityTime);
        
        console.log(`Player hit! Health: ${this.health}/${this.maxHealth}`);
        
        if (this.health <= 0) {
            this.gameOver();
        }
    },
    
    createHealthDisplay: function () {
        // Create health text in VR space
        let healthText = document.createElement('a-text');
        healthText.setAttribute('id', 'health-display');
        healthText.setAttribute('value', `Health: ${this.health}/${this.maxHealth}`);
        healthText.setAttribute('position', '-2 2 -2');
        healthText.setAttribute('color', 'white');
        healthText.setAttribute('scale', '2 2 2');
        document.querySelector('a-scene').appendChild(healthText);
    },
    
    updateHealthDisplay: function () {
        let healthDisplay = document.querySelector('#health-display');
        if (healthDisplay) {
            healthDisplay.setAttribute('value', `Health: ${this.health}/${this.maxHealth}`);
        }
    },
    
    gameOver: function () {
        console.log('Game Over!');
        // Create game over text
        let gameOverText = document.createElement('a-text');
        gameOverText.setAttribute('value', 'GAME OVER');
        gameOverText.setAttribute('position', '0 0 -2');
        gameOverText.setAttribute('color', 'red');
        gameOverText.setAttribute('scale', '3 3 3');
        gameOverText.setAttribute('align', 'center');
        document.querySelector('a-scene').appendChild(gameOverText);
        
        // Stop enemy spawning
        let spawner = document.querySelector('[enemy-spawner]');
        if (spawner) {
            spawner.removeAttribute('enemy-spawner');
        }
    }
});

// Fixed Player Shooting for Quest 3
AFRAME.registerComponent('player-shooting', {
    init: function () {
        this.bullets = [];
        this.canShoot = true;
        this.shootCooldown = 300;
        this.points = 0;
        this.createPointsDisplay();
        
        // Wait for controllers then setup shooting
        setTimeout(() => {
            this.setupShootingControls();
        }, 3000);
    },
    
    setupShootingControls: function () {
        let leftController = document.querySelector('#leftController');
        let rightController = document.querySelector('#rightController');
        
        console.log('Setting up shooting controls...');
        
        if (leftController) {
            leftController.addEventListener('triggerdown', () => {
                console.log('Left trigger pressed - shooting!');
                this.shoot();
            });
        }
        
        if (rightController) {
            rightController.addEventListener('triggerdown', () => {
                console.log('Right trigger pressed - shooting!');
                this.shoot();
            });
        }
        
        // Keyboard backup for testing
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                this.shoot();
            }
        });
    },
    
    shoot: function () {
        if (!this.canShoot) return;
        
        let playerPosition = this.el.getAttribute('position');
        
        let bullet = document.createElement('a-entity');
        bullet.setAttribute('geometry', 'primitive: dodecahedron; radius: 0.075');
        bullet.setAttribute('material', 'color: white');
        bullet.setAttribute('position', `${playerPosition.x} ${playerPosition.y + 0.2} ${playerPosition.z}`);
        bullet.setAttribute('animation', `property: position; to: ${playerPosition.x} 4 ${playerPosition.z}; dur: 1000`);
        bullet.setAttribute('class', 'bullet');
        
        document.querySelector('a-scene').appendChild(bullet);
        this.bullets.push(bullet);
        
        setTimeout(() => {
            if (bullet.parentNode) {
                bullet.parentNode.removeChild(bullet);
            }
            this.bullets = this.bullets.filter(b => b !== bullet);
        }, 1000);
        
        this.canShoot = false;
        setTimeout(() => {
            this.canShoot = true;
        }, this.shootCooldown);
        
        console.log('Bullet fired!');
    },
    
    tick: function () {
        this.checkBulletCollisions();
    },
    
    checkBulletCollisions: function () {
        let enemies = document.querySelectorAll('.enemy');
        
        this.bullets.forEach((bullet) => {
            if (!bullet.parentNode) return;
            
            let bulletPosition = bullet.getAttribute('position');
            
            enemies.forEach((enemy) => {
                if (!enemy.parentNode) return;
                
                let enemyPosition = enemy.getAttribute('position');
                let distance = this.getDistance(bulletPosition, enemyPosition);
                
                if (distance < 0.3) {
                    this.addPoints(10);
                    
                    if (bullet.parentNode) {
                        bullet.parentNode.removeChild(bullet);
                    }
                    if (enemy.parentNode) {
                        enemy.parentNode.removeChild(enemy);
                    }
                    
                    this.bullets = this.bullets.filter(b => b !== bullet);
                    console.log(`Enemy destroyed! Points: ${this.points}`);
                }
            });
        });
    },
    
    getDistance: function (pos1, pos2) {
        let dx = pos1.x - pos2.x;
        let dy = pos1.y - pos2.y;
        let dz = pos1.z - pos2.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
    },
    
    addPoints: function (points) {
        this.points += points;
        this.updatePointsDisplay();
    },
    
    createPointsDisplay: function () {
        let pointsText = document.createElement('a-text');
        pointsText.setAttribute('id', 'points-display');
        pointsText.setAttribute('value', `Points: ${this.points}`);
        pointsText.setAttribute('position', '2 2 -2');
        pointsText.setAttribute('color', 'yellow');
        pointsText.setAttribute('scale', '2 2 2');
        document.querySelector('a-scene').appendChild(pointsText);
    },
    
    updatePointsDisplay: function () {
        let pointsDisplay = document.querySelector('#points-display');
        if (pointsDisplay) {
            pointsDisplay.setAttribute('value', `Points: ${this.points}`);
        }
    }
});

// Fixed Quest 3 Movement with Thumbstick (no button conflicts)
AFRAME.registerComponent('quest-player-controls', {
    init: function () {
        this.keys = {};
        
        // Keyboard fallback
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    },
    
    tick: function () {
        let position = this.el.getAttribute('position');
        let moved = false;
        
        // Keyboard controls (for testing)
        if (this.keys['ArrowLeft'] && position.x > -4) {
            position.x -= 0.05;
            moved = true;
        }
        if (this.keys['ArrowRight'] && position.x < 4) {
            position.x += 0.05;
            moved = true;
        }
        
        // Quest 3 Thumbstick controls
        let leftController = document.querySelector('#leftController');
        if (leftController && leftController.components['tracked-controls']) {
            let gamepad = leftController.components['tracked-controls'].controller;
            if (gamepad && gamepad.axes && gamepad.axes.length >= 2) {
                let thumbstickX = gamepad.axes[0]; // Try axis 0 for Quest 3
                
                if (Math.abs(thumbstickX) > 0.3) {
                    console.log('Thumbstick X:', thumbstickX);
                    
                    if (thumbstickX < -0.3 && position.x > -4) {
                        position.x -= 0.05;
                        moved = true;
                    }
                    if (thumbstickX > 0.3 && position.x < 4) {
                        position.x += 0.05;
                        moved = true;
                    }
                }
            }
        }
        
        if (moved) {
            this.el.setAttribute('position', position);
        }
    }
});
    </script>
</body>
</html>
